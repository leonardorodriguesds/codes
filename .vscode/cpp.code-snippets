{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"C++ Competitive Programming": {
		"prefix": "cpp-template",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#define DEBUG false",
		  "#define debugf if (DEBUG) printf",
		  "#define MAXN 200309",
		  "#define MAXM 900009",
		  "#define ALFA            256",
		  "#define MOD             1000000007",
		  "#define INF             0x3f3f3f3f",
		  "#define INFLL           0x3f3f3f3f3f3f3f3f",
		  "#define EPS             (1e-9)",
		  "#define PI              3.141592653589793238462643383279502884",
		  "#define all(a)          a.begin(), a.end()",
		  "#define fill(t,v)       memset(t, v, sizeof(t))",
		  "#define sz(a)           ((int)(a.size()))",
		  "#define LOG2(X)         ((unsigned) (8*sizeof(unsigned long long) - __builtin_clzll((X)) - 1))",
		  "#define ispow2(v)       ((int(v) & (int(v) - 1)) == 0)",
		  "#define scanf2(a, b)    (scanf(\"%d %d\", &a, &b))",
		  "#define scanf3(a, b, c) (scanf(\"%d %d %d\", &a, &b, &c))",
		  "#define FOR(x,n) for(int x = 0; (x)<int(n); (x)++)",
		  "#define FOR1(x,n) for(int x = 1; (x)<=int(n); (x)++)",
		  "#define REP(x,n) for(int x = int(n)-1; (x)>=0; (x)--)",
		  "#define REP1(x,n) for(int x = int(n); (x)>0; (x)--)",
		  "#define pb push_back",
		  "#define pf push_front",
		  "#define fi first",
		  "#define se second",
		  "#define mp make_pair",
		  "#define mset(x, y) memset(&x, (y), sizeof(x))",
		  "using namespace std;",
		  "typedef long long ll;",
		  "typedef pair<int, int> ii;",
		  "typedef vector<int> vi;",
		  "typedef vector<vi> vvi;",
		  "typedef vector<ii> vii;",
		  "typedef vector<pair<int, ii>> vpii;",
		  "typedef vector<string> vs;",
		  "typedef priority_queue<int, vector<int>, greater<int>> pqi;",
		  "typedef vector<pqi> vpqi;",
		  "",        
		  "void init_problem(int n) {",
		  "    ",
		  "}",
		  "",
		  "int main() {",
		  "    ios_base::sync_with_stdio(false); ",
		  "    $1",
		  "    return 0;",
		  "}"
		],
		"description": "C++ Competitive Programming Template"
	},
	"Djikstra algorithm": {
		"prefix": "dkijstra",
		"body": [
			"int dkijstra(int x, int y, vector<vii>& graph) {",
			"    const int SINF = INT_MAX;",
			"    int n = graph.size();",
			"    long long d[501];",
			"    for (int u = 0; u < n; u++)",
			"        d[u] = SINF;",
			"    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> aux;",
			"    d[x] = 0;",
			"    aux.emplace(d[x], x);",
			"    ll dt, w;",
			"    int u, v;",
			"    while (!aux.empty()) {",
			"        tie(dt, u) = aux.top();",
			"        aux.pop();",
			"        if (u == y)",
			"            return dt;",
			"        for (auto edge : graph[u]) {",
			"            tie(w, v) = edge;",
			"            if (d[v] > d[u] + w) {",
			"                d[v] = d[u] + w;",
			"                aux.emplace(d[v], v);",
			"            }",
			"        }",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Function to find the shortest path between two nodes in a graph."
	},
	"Segment Tree": {
		"prefix": "segmentTree",
		"body": [
		  "$1 neutral = $3;",
		  "",
		  "$1 compare($1 a, $1 b) {",
		  "    return $2;",
		  "}",
		  "",
		  "void segmentTree(int node, int b, int e, vi& arr, vi& segTree) {",
		  "    if (b == e) {",
		  "        segTree[node] = arr[b];",
		  "    } else {",
		  "        int mid = (b + e) >> 1, l = node << 1, r = node << 1 | 1;",
		  "        segmentTree(l, b, mid, arr, segTree);",
		  "        segmentTree(r, mid + 1, e, arr, segTree);",
		  "        segTree[node] = compare(segTree[l], segTree[r]);",
		  "    }",
		  "}",
		  "",
		  "$1 queryUtils(int node, int b, int e, int L, int R, vi& segTree) {",
		  "    if (b >= L && e <= R) {",
		  "        return segTree[node];",
		  "    }",
		  "",
		  "    if (b > R || e < L) {",
		  "        return neutral;",
		  "    }",
		  "",
		  "    int mid = (b + e) >> 1, l = node << 1, r = node << 1 | 1;",
		  "    return compare(queryUtils(l, b, mid, L, R, segTree), queryUtils(r, mid + 1, e, L, R, segTree));",
		  "}",
		  "",
		  "$1 query(int n, int i, int j, vi& segTree) {",
		  "    return queryUtils(1, 0, n - 1, min(i, j), max(i, j), segTree);",
		  "}"
		],
		"description": "Segment Tree snippet"
	},
	"CPP LCA Snippet": {
		"prefix": "LCA",
		"body": [
			"vector<ii> adjlist[MAXN];",
			"int level[MAXN], N, P[MAXN][MAXLOGN], D[MAXN][MAXLOGN];",
			"const int neutral = 0;",
			"int comp(int a, int b) {",
			"    return a + b;",
			"}",
			"",
			"void depthdfs(int u) {",
			"    int i;",
			"    FOR(i, adjlist[u].size()) {",
			"        int v = adjlist[u][i].first, w = adjlist[u][i].second;",
			"        if (v == P[u][0]) continue;",
			"        P[v][0] = u; D[v][0] = w;",
			"        level[v] = 1 + level[u];",
			"        depthdfs(v);",
			"    }",
			"}",
			"",
			"void prepare(int root) {",
			"    level[root] = 0;",
			"    P[root][0] = root; D[root][0] = neutral;",
			"    depthdfs(root);",
			"    int j, i;",
			"    FOR1(j, (MAXLOGN + 1)) {",
			"        FOR1(i, N) {",
			"            P[i][j] = P[P[i][j-1]][j-1];",
			"            D[i][j] = comp(D[P[i][j-1]][j-1], D[i][j-1]);",
			"        }",
			"    }",
			"}",
			"",
			"ii LCA(int u, int v) {",
			"    if (level[u] > level[v]) swap(u, v);",
			"    int d = level[v] - level[u], ans = neutral;",
			"    int i;",
			"    FOR(i, MAXLOGN) {",
			"        if (d & (1 << i)) {",
			"            ans = comp(ans, D[v][i]);",
			"            v = P[v][i];",
			"        }",
			"    }",
			"    if (u == v) return ii(u, ans);",
			"    REP(i, MAXLOGN) {",
			"        while (P[u][i] != P[v][i]) {",
			"            ans = comp(ans, D[v][i]);",
			"            ans = comp(ans, D[u][i]);",
			"            u = P[u][i]; v = P[v][i];",
			"        }",
			"    }",
			"    ans = comp(ans, D[v][0]);",
			"    ans = comp(ans, D[u][0]);",
			"    return ii(P[u][0], ans);",
			"}"
		],
		"description": "Snippet for Lowest Common Ancestor (LCA) in a tree"
	}	
	  
}