{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"C++ Competitive Programming": {
		"prefix": "cpp-template",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#define DEBUG false",
		  "#define debugf if (DEBUG) printf",
		  "#define MAXN 200309",
		  "#define MAXM 900009",
		  "#define ALFA            256",
		  "#define MOD             1000000007",
		  "#define INF             0x3f3f3f3f",
		  "#define INFLL           0x3f3f3f3f3f3f3f3f",
		  "#define EPS             (1e-9)",
		  "#define PI              3.141592653589793238462643383279502884",
		  "#define all(a)          a.begin(), a.end()",
		  "#define fill(t,v)       memset(t, v, sizeof(t))",
		  "#define sz(a)           ((int)(a.size()))",
		  "#define LOG2(X)         ((unsigned) (8*sizeof(unsigned long long) - __builtin_clzll((X)) - 1))",
		  "#define ispow2(v)       ((int(v) & (int(v) - 1)) == 0)",
		  "#define scanf2(a, b)    (scanf(\"%d %d\", &a, &b))",
		  "#define scanf3(a, b, c) (scanf(\"%d %d %d\", &a, &b, &c))",
		  "#define FOR(x,n) for(int x = 0; (x)<int(n); (x)++)",
		  "#define FOR1(x,n) for(int x = 1; (x)<=int(n); (x)++)",
		  "#define REP(x,n) for(int x = int(n)-1; (x)>=0; (x)--)",
		  "#define REP1(x,n) for(int x = int(n); (x)>0; (x)--)",
		  "#define pb push_back",
		  "#define pf push_front",
		  "#define fi first",
		  "#define se second",
		  "#define mp make_pair",
		  "#define mset(x, y) memset(&x, (y), sizeof(x))",
		  "using namespace std;",
		  "typedef long long ll;",
		  "typedef pair<int, int> ii;",
		  "typedef vector<int> vi;",
		  "typedef vector<vi> vvi;",
		  "typedef vector<ii> vii;",
		  "typedef vector<pair<int, ii>> vpii;",
		  "typedef vector<string> vs;",
		  "typedef priority_queue<int, vector<int>, greater<int>> pqi;",
		  "typedef vector<pqi> vpqi;",
		  "",        
		  "void init_problem(int n) {",
		  "    ",
		  "}",
		  "",
		  "int main() {",
		  "    ios_base::sync_with_stdio(false); ",
		  "    $1",
		  "    return 0;",
		  "}"
		],
		"description": "C++ Competitive Programming Template"
	},
	"Djikstra algorithm": {
		"prefix": "dkijstra",
		"body": [
			"int dkijstra(int x, int y, vector<vii>& graph) {",
			"    const int SINF = INT_MAX;",
			"    int n = graph.size();",
			"    long long d[501];",
			"    for (int u = 0; u < n; u++)",
			"        d[u] = SINF;",
			"    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> aux;",
			"    d[x] = 0;",
			"    aux.emplace(d[x], x);",
			"    ll dt, w;",
			"    int u, v;",
			"    while (!aux.empty()) {",
			"        tie(dt, u) = aux.top();",
			"        aux.pop();",
			"        if (u == y)",
			"            return dt;",
			"        for (auto edge : graph[u]) {",
			"            tie(w, v) = edge;",
			"            if (d[v] > d[u] + w) {",
			"                d[v] = d[u] + w;",
			"                aux.emplace(d[v], v);",
			"            }",
			"        }",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Function to find the shortest path between two nodes in a graph."
	},
	"Segment Tree": {
		"prefix": "segmentTree",
		"body": [
		  "$1 neutral = $3;",
		  "",
		  "$1 compare($1 a, $1 b) {",
		  "    return $2;",
		  "}",
		  "",
		  "void segmentTree(int node, int b, int e, vi& arr, vi& segTree) {",
		  "    if (b == e) {",
		  "        segTree[node] = arr[b];",
		  "    } else {",
		  "        int mid = (b + e) >> 1, l = node << 1, r = node << 1 | 1;",
		  "        segmentTree(l, b, mid, arr, segTree);",
		  "        segmentTree(r, mid + 1, e, arr, segTree);",
		  "        segTree[node] = compare(segTree[l], segTree[r]);",
		  "    }",
		  "}",
		  "",
		  "$1 queryUtils(int node, int b, int e, int L, int R, vi& segTree) {",
		  "    if (b >= L && e <= R) {",
		  "        return segTree[node];",
		  "    }",
		  "",
		  "    if (b > R || e < L) {",
		  "        return neutral;",
		  "    }",
		  "",
		  "    int mid = (b + e) >> 1, l = node << 1, r = node << 1 | 1;",
		  "    return compare(queryUtils(l, b, mid, L, R, segTree), queryUtils(r, mid + 1, e, L, R, segTree));",
		  "}",
		  "",
		  "$1 query(int n, int i, int j, vi& segTree) {",
		  "    return queryUtils(1, 0, n - 1, min(i, j), max(i, j), segTree);",
		  "}"
		],
		"description": "Segment Tree snippet"
	},
	"CPP LCA Snippet": {
		"prefix": "LCA",
		"body": [
			"vector<ii> adjlist[MAXN];",
			"int level[MAXN], N, P[MAXN][MAXLOGN], D[MAXN][MAXLOGN];",
			"const int neutral = 0;",
			"int comp(int a, int b) {",
			"    return a + b;",
			"}",
			"",
			"void depthdfs(int u) {",
			"    int i;",
			"    FOR(i, adjlist[u].size()) {",
			"        int v = adjlist[u][i].first, w = adjlist[u][i].second;",
			"        if (v == P[u][0]) continue;",
			"        P[v][0] = u; D[v][0] = w;",
			"        level[v] = 1 + level[u];",
			"        depthdfs(v);",
			"    }",
			"}",
			"",
			"void prepare(int root) {",
			"    level[root] = 0;",
			"    P[root][0] = root; D[root][0] = neutral;",
			"    depthdfs(root);",
			"    int j, i;",
			"    FOR1(j, (MAXLOGN + 1)) {",
			"        FOR1(i, N) {",
			"            P[i][j] = P[P[i][j-1]][j-1];",
			"            D[i][j] = comp(D[P[i][j-1]][j-1], D[i][j-1]);",
			"        }",
			"    }",
			"}",
			"",
			"ii LCA(int u, int v) {",
			"    if (level[u] > level[v]) swap(u, v);",
			"    int d = level[v] - level[u], ans = neutral;",
			"    int i;",
			"    FOR(i, MAXLOGN) {",
			"        if (d & (1 << i)) {",
			"            ans = comp(ans, D[v][i]);",
			"            v = P[v][i];",
			"        }",
			"    }",
			"    if (u == v) return ii(u, ans);",
			"    REP(i, MAXLOGN) {",
			"        while (P[u][i] != P[v][i]) {",
			"            ans = comp(ans, D[v][i]);",
			"            ans = comp(ans, D[u][i]);",
			"            u = P[u][i]; v = P[v][i];",
			"        }",
			"    }",
			"    ans = comp(ans, D[v][0]);",
			"    ans = comp(ans, D[u][0]);",
			"    return ii(P[u][0], ans);",
			"}"
		],
		"description": "Snippet for Lowest Common Ancestor (LCA) in a tree"
	},
	"Starting":{
        "prefix": "start",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ALFA            256",
            "#define MOD             1000000007",
            "#define INF             0x3f3f3f3f",
            "#define INFLL           0x3f3f3f3f3f3f3f3f",
            "#define EPS             (1e-9)",
            "#define PI              3.141592653589793238462643383279502884",
            "#define all(a)          a.begin(), a.end()",
            "#define fill(t,v)       memset(t, v, sizeof(t))",
            "#define sz(a)           ((int)(a.size()))",
            "#define LOG2(X)         ((unsigned) (8*sizeof(unsigned long long) - __builtin_clzll((X)) - 1))",
            "#define ispow2(v)       ((int(v) & (int(v) - 1)) == 0)",
            "#define scanf2(a, b)    (scanf(\"%d %d\", &a, &b))",
            "#define scanf3(a, b, c) (scanf(\"%d %d %d\", &a, &b, &c))",
            "typedef long long ll;",
            "typedef pair<int, int> ii;",
            "typedef vector<int> vi;",
            "typedef vector<vi> vvi;",
            "typedef vector<ii> vii;",
            "typedef vector<pair<int, ii>> vpii;",
            "typedef vector<string> vs;",
            "",
            "int main(){",
            "\t$0",
            "\treturn 0;",
           "}"
        ],
        "description": "All stuffs for starting code"
    },
    "Binary search":{
        "prefix": "binsearch",
        "body": [
            "int left, right, middle;",
            "left = 0;",
            "right = ${max};",
            "while(left <= right){",
            "\tmiddle = (left + right) / 2;",
            "\t$0",
            "}"
        ],
        "description": "Template binary search"
    },
    "UnionFind":{
        "prefix": "unionfind",
        "body": [
            "class UnionFind{",
            "\tvi id, size;",
            "\t",
            "\tint _find(int i){",
            "\t\tif(id[i] == i) return i;",
            "\t\treturn id[i] = _find(id[i]);",
            "\t}",
            "\tvoid _union(int i, int j){",
            "\t\tint p = _find(i);",
            "\t\tint q = _find(j);",
            "\t\tif(p == q) return;",
            "\t\tif(size[p] > size[q]) swap(p, q);",
            "\t\tid[p] = q;",
            "\t\tsize[q] += size[p];",
            "\t\ttotal--;",
            "\t}",
            "\t",
            "\tpublic:",
            "\t\tint total;",
            "\t\tUnionFind(int n): total(n), id(n, 0), size(n, 1){",
            "\t\t\tfor (int i = 0; i < n; i++) id[i] = i;",
            "\t\t};",
            "\t\tint find(int i){ return _find(i); };",
            "\t\tvoid c_union(int i, int j){ return _union(i, j); };",
            "};"
        ],
        "description": "Template for union find"
    },
    "Kruskal's algorithm":{
        "prefix": "kruskal",
        "body": [
            "${1|vpii,int,ll|} kruskal(int n, vpii& edges){",
            "\tUnionFind uf(n);",
            "\t${1} ans = 0;",
            "\tsort(all(edges));",
            "\tfor(auto edge: edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t\tans += edge.first;",
            "\t}",
            "\treturn ans;",
            "}"
        ],
        "description": "Template for Kruskal's algorithm"
    },
    "Prim's algorithm":{
        "prefix": "Prim's",
        "body": [
            "vii prims_mst(int n, vvii& graph){",
            "\tvii mst;",
            "\tint inMST[n];",
            "\tint cost[n];",
            "\tint parent[n];",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tcost[i] = INF, inMST[i] = -1, parent[i] = -1;",
            "\tpriority_queue<ii, vector<ii>, greater<ii>> aux;",
            "\taux.emplace(0, 0);",
            "\tcost[0] = 0;",
            "\tint u, dt;",
            "\twhile(!aux.empty()){",
            "\t\ttie(dt, u) = aux.top(), aux.pop();",
            "\t\tinMST[u] = 1;",
            "\t\tfor(auto e: graph[u]){",
            "\t\t\tif(!~inMST[e.second] and e.first < cost[e.second])",
            "\t\t\t\tparent[e.second] = u, aux.push(e), cost[e.second] = e.first;",
            "\t\t}",
            "\t}",
            "\tfor(int i = 1; i < n; i++)",
            "\t\tmst.emplace_back(i, parent[i]);",
            "\treturn mst;",
            "}"
        ],
        "description": "Template for Prim's algorithm"
    },
    "ForN code":{
        "prefix": "forN",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\t$0",
            "}",
        ],
        "description": "For 0 to N code"
    },
    "ForArray code":{
        "prefix": "forArray",
        "body": [
            "for(int ${index} = 0; ${index} < sz(${array}); ${index}++){",
            "\t$0",
            "}",
        ],
        "description": "For through array"
    },
    "ForN Scanf1":{
        "prefix": "nscanf1",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\tint ${a};",
            "\tscanf(\"%d\", &${a});",
            "\t$0",
            "}",
        ],
        "description": "For from 0 to n and scanf 2 elements"
    },
    "ForN Scanf2":{
        "prefix": "nscanf2",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\tint ${a}, ${b};",
            "\tscanf(\"%d %d\", &${a}, &${b});",
            "\t$0",
            "}",
        ],
        "description": "For from 0 to n and scanf 2 elements"
    },
    "ForN Scanf3":{
        "prefix": "nscanf3",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\tint ${a}, ${b}, ${w};",
            "\tscanf(\"%d %d %d\", &${a}, &${b}, &${w});",
            "\t$0",
            "}",
        ],
        "description": "For from 0 to n and scanf 3 elements"
    },
    "Basic graph":{
        "prefix": "graph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tlist<${2|int,ii|}> *adj;",
            "\tint *visited;",
            "\tvoid resetVisited(){",
            "\t\tmemset(this->visited, -1, this->n * sizeof(int));",
            "\t}",
            "",
            "\tpublic:",
            "\t\tGraph(int n): n(n){",
            "\t\t\tthis->adj = new list<${2|int,ii|}>[n];",
            "\t\t\tthis->visited = new int[n];",
            "\t\t};",
            "\t\t~Graph(){",
            "\t\t\tdelete [] this->adj;",
            "\t\t\tdelete [] this->visited;",
            "\t\t};",
            "\t\tvoid addEdge(int u, int v, int c, bool directed = ${1|true,false|});",
            "};",
            "void Graph::addEdge(int u, int v, int c, bool directed){",
            "\tthis->adj[u].${3|push_back,emplace_back|}(c, v);",
            "\tif(directed)",
            "\t\tthis->adj[v].${3|push_back,emplace_back|}(c, u);",
            "}"
        ],
        "description": "basic system graph"
    },
    "bfs graph":{
        "prefix": "bfsgraph",
        "body": [
            "int bfs(int start, int end);",
            "int Graph::bfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tqueue<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.front();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
        ],
        "description": "bfs for graph class"
    },
    "Graph completed template":{
        "prefix": "cgraph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tlist<ii> *adj;",
            "\tvpii edges;",
            "\tint *visited;",
            "",
            "\tpublic:",
            "\t\tGraph(int n);",
            "\t\t~Graph();",
            "\t\tvoid addEdge(int u, int v, int c, bool directed = false);",
            "\t\tvoid removeAdj(int u, int v, bool directed = false);",
            "\t\tvoid removeEdge(int u, int v);",
            "\t\tvii primsMST();",
            "\t\tvpii kruskalMST();",
            "\t\tll djikstra(int start, int end);",
            "\t\tint bfs(int start, int end);",
            "\t\tint dfs(int start, int end);",
            "};",
            "Graph::Graph(int n){",
            "\tthis->n = n;",
            "\tthis->adj = new list<ii>[n];",
            "\tthis->visited = new int[n];",
            "}",
            "Graph::~Graph(){",
            "\tdelete [] this->adj;",
            "\tdelete [] this->visited;",
            "}",
            "void Graph::addEdge(int u, int v, int c, bool directed){",
            "\tthis->adj[u].emplace_back(c, v);",
            "\tthis->edges.emplace_back(c, make_pair(u, v));",
            "\tif(directed)",
            "\t\tthis->adj[v].emplace_back(c, u);",
            "}",
            "void Graph::removeAdj(int u, int v, bool directed){",
            "\tfor(auto it = this->adj[u].begin(); it != this->adj[u].end(); it++){",
            "\t\tif(it->second == v)",
            "\t\t\tthis->adj[u].erase(it); ",
            "\t}",
            "\tif(!directed)",
            "\t\treturn;",
            "\tfor(auto it = this->adj[v].begin(); it != this->adj[v].end(); it++){",
            "\t\tif(it->second == u)",
            "\t\t\tthis->adj[v].erase(it); ",
            "\t}",
            "}",
            "void Graph::removeEdge(int u, int v){",
            "\tfor(auto it = this->edges.begin(); it != this->edges.end(); it++){",
            "\t\tif((it->second.first == u and it->second.second == v) or (it->second.first == v and it->second.second == u))",
            "\t\t\tthis->edges.erase(it);",
            "\t}",
            "}",
            "vii Graph::primsMST(){",
            "\tvii mst;",
            "\tint inMST[n];",
            "\tint coust[n];",
            "\tint parent[n];",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tcoust[i] = INF, inMST[i] = -1, parent[i] = -1;",
            "\tpriority_queue<ii, vector<ii>, greater<ii>> aux;",
            "\taux.emplace(0, 0);",
            "\tcoust[0] = 0;",
            "\tint u, dt;",
            "\tfor(int i = 0; i < n - 1; i++){",
            "\t\ttie(dt, u) = aux.top(), aux.pop();",
            "\t\tinMST[u] = 1;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~inMST[e.second] and e.first < coust[e.second])",
            "\t\t\t\tparent[e.second] = u, aux.push(e), coust[e.second] = e.first;",
            "\t\t}",
            "\t}",
            "\tfor(int i = 1; i < n; i++)",
            "\t\tmst.emplace_back(i, parent[i]);",
            "\treturn mst;",
            "}",
            "vpii Graph::kruskalMST(){",
            "\tUnionFind uf(this->n);",
            "\tvpii ans;",
            "\tsort(all(this->edges));",
            "\tfor(auto edge: this->edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t}",
            "\treturn ans;",
            "}",
            "int Graph::dfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tstack<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.top();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
            "int Graph::bfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tqueue<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.front();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
        ],
        "description": "Graph completed template"
    },
    "Kruskal Graph template":{
        "prefix": "kgraph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tvpii edges;",
            "\tint *visited;",
            "",
            "\tpublic:",
            "\t\tGraph(int n);",
            "\t\t~Graph();",
            "\t\tvoid addEdge(int u, int v, int c);",
            "\t\tvpii kruskalMST();",
            "};",
            "Graph::Graph(int n){",
            "\tthis->n = n;",
            "\tthis->visited = new int[n];",
            "}",
            "Graph::~Graph(){",
            "\tdelete [] this->visited;",
            "}",
            "void Graph::addEdge(int u, int v, int c){",
            "\tthis->edges.emplace_back(c, make_pair(u, v));",
            "}",
            "vpii Graph::kruskalMST(){",
            "\tUnionFind uf(this->n);",
            "\tvpii ans;",
            "\tsort(all(this->edges));",
            "\tfor(auto edge: this->edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t}",
            "\treturn ans;",
            "}",
        ],
        "description": "Kruskal Graph set"
    },
    "Min Sparce table class":{
        "prefix": "minsparcetable",
        "body": [
            "class SparseT{",
            "\tint n;",
            "\tint lgN;",
            "\t${type}* data;",
            "\t${type}** table;",
            "\tauto (*f)(${type} a, ${type} b)->${type};",
            "",
            "\tvoid buildsparsetable();",
            "\tpublic:",
            "\t\tSparseT(int n);",
            "\t\t~SparseT();",
            "\t\tvoid buildTable(${type} (*f)(${type}, ${type}));",
            "\t\t${type} query(${type} i, ${type} j);",
            "};",
            "SparseT::SparseT(int n){",
            "\tthis->n = n;",
            "\tthis->lgN = (int)LOG2(n);",
            "\tthis->data = new int[n];",
            "\tthis->table = new ${type}*[n];",
            "\tfor(int i = 0; i < n; i++)",
            "\t\tthis->table[i] = new ${type}[this->lgN + 1];",
            "}",
            "SparseT::~SparseT(){",
            "\tdelete [] this->data;",
            "\tfor(int i = 0; i < n; i++)",
            "\t\tdelete[] this->table[i];",
            "\tdelete [] this->table;",
            "}",
            "void SparseT::buildTable(${type} (*f)(${type}, ${type})){",
            "\tfor(int i = 0; i < this->n; i++)",
            "\t\tscanf(\"${macrotype}\", &this->data[i]);",
            "\tthis->f = f;",
            "\tthis->buildsparsetable();",
            "}",
            "void SparseT::buildsparsetable(){",
            "\tfor(int i = 0; i < this->n; i++)",
            "\t\tthis->table[i][0] = this->data[i];",
            "\tfor(int j = 1; (1 << j) <= this->n; j++)",
            "\t\tfor(int i = 0; (i + (1 << j) - 1) < n; i++)",
            "\t\t\tthis->table[i][j] = this->f(this->table[i][j - 1], ",
            "\t\t\t\t\t\t\t\tthis->table[i + (1 << (j - 1))][j - 1]);",
            "}",
            "${type} SparseT::query(int l, int r){",
            "\tint j = (int)LOG2(r - l + 1);",
            "\treturn this->f(this->table[l][j], this->table[r - (1 << j) + 1][j]);",
            "}"
        ],
        "description": "Sparce table to min value"
    },
    "Rabin Karp algorithm":{
        "prefix": "rabinkarp",
        "body": [
            "class RabinKarp{",
            "\tint n, m, p;",
            "\tstring sb;",
            "\tvector<ll> hsh, pw;",
            "\t",
            "\tpublic:",
            "\t\tRabinKarp(string str, int p, int m): sb(str), p(p), m(m){",
            "\t\t\tthis->n = sz(str);",
            "\t\t\thsh.resize(n), pw.resize(n);",
            "\t\t\thsh[0] = str[0]; pw[0] = 1;",
            "\t\t\tfor(int i = 1; i < n; i++){",
            "\t\t\t\thsh[i] = ((hsh[i - 1] * p) + str[i]) % m;",
            "\t\t\t\tpw[i] = (pw[i - 1] * p) % m;",
            "\t\t\t}",
            "\t\t};",
            "\t\tll hash(int i, int j){",
            "\t\t\tll ans = hsh[j];",
            "\t\t\tif(i > 0) ans = (ans - ((hsh[i - 1] * 1ll * pw[j - i + 1]) % m) + m) % m;",
            "\t\t\treturn ans;",
            "\t\t}",
            "\t\tll gethash(string str, int z){",
            "\t\t\tll ans = str[0];",
            "\t\t\tfor(int i = 1; i < z; i++)",
            "\t\t\t\tans = ((ans * p) + str[i]) % m;",
            "\t\t\treturn ans;",
            "\t\t};",
            "\t\tint check(string str){",
            "\t\t\tint z = sz(str), i;",
            "\t\t\tll lookfor = this->gethash(str, z);",
            "\t\t\tbool flag = true;",
            "\t\t\tfor(i = 0; i < (this->n - z + 1) and flag; i++){",
            "\t\t\t\tflag = flag && !(this->hash(i, (i + z - 1)) == lookfor);",
            "\t\t\t\tif(!flag)",
            "\t\t\t\t\tfor(int j = 0; j < z and !flag; j++)",
            "\t\t\t\t\t\tflag = (this->sb[i + j] != str[j]);",
            "\t\t\t}",
            "\t\t\treturn (flag)? -1 : --i;",
            "\t\t};",
            "};"
        ],
        "description": "Rabin karp algorithm to pattern search"
    },
    "segment tree":{
        "prefix": "segmenttree",
        "body": [
            "template <class T> class SegmentTree{",
            "\tint n, size;",
            "\tT neutral;",
            "\tvector<T> num;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tvoid update(int sti, int l, int r, int i, T x){",
            "\t\tif(l == r and l == i){",
            "\t\t\tthis->num[sti] = this->u(this->num[sti], x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i)",
            "\t\t\treturn;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tthis->update(2 * sti + 1, l, mid, i, x);",
            "\t\tthis->update(2 * sti + 2, mid + 1, r, i, x);",
            "\t\tthis->num[sti] = this->f(this->num[2 * sti + 1], this->num[2 * sti + 2]);",
            "\t}",
            "\tT query(int sti, int stl, int str, int l, int r){",
            "\t\tif(str < l or stl > r)",
            "\t\t\treturn this->neutral;",
            "\t\tif(stl >= l and str <= r)",
            "\t\t\treturn this->num[sti];",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->query(2 * sti + 1, stl, mid, l, r), this->query(2 * sti + 2, mid + 1, str, l, r));",
            "\t}",
            "\tpublic:",
            "\t\tSegmentTree(int n, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->size = 2 * (int)pow(2, (int)(ceil(log2(n)))) - 1;",
            "\t\t\tnum = vector<T>(this->size, 0);",
            "\t\t};",
            "\t\tvoid update(int i, T x){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, x);",
            "\t\t};",
            "\t\tT query(int l, int r){",
            "\t\t\treturn this->query(0, 0, this->n - 1, l, r);",
            "\t\t};",
            "};"
        ],
        "description": "Class for linear segment tree"
    },
    "SegmentTree2D":{
        "prefix": "2dsegmenttree",
        "body":[
            "template <class T> class SegmentTree2D{",
            "\tint n, m, sizen, sizem;",
            "\tT neutral;",
            "\tvector<vector<T>> st;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tvoid updatex(int sti, int l, int r, int i, int node, T x){",
            "\t\tif(l == r and l == i){",
            "\t\t\tthis->st[node][sti] = this->u(this->st[node][sti], x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->updatex(2 * sti + 1, l, mid, i, node, x);",
            "\t\telse this->updatex(2 * sti + 2, mid + 1, r, i, node, x);",
            "\t\tthis->st[node][sti] = this->f(this->st[node][2 * sti + 1], this->st[node][2 * sti + 2]);",
            "\t}",
            "\tvoid update(int sti, int l, int r, int i, vector<T>& a){",
            "\t\tif(l == r and l == i){",
            "\t\t\tfor(int j = 0; j < this->m; j++)",
            "\t\t\t\tthis->updatex(0, 0, this->m - 1, j, sti, a[j]);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->update(2 * sti + 1, l, mid, i, a);",
            "\t\telse this->update(2 * sti + 2, mid + 1, r, i, a);",
            "\t\tfor(int z = 0; z < this->m; z++)",
            "\t\t\tthis->st[sti][z] = this->f(this->st[2 * sti + 1][z], this->st[2 * sti + 2][z]);",
            "\t}",
            "\tvoid update(int sti, int l, int r, int i, int j, T x){",
            "\t\tif(l == r and l == i)",
            "\t\t\treturn this->updatex(0, 0, this->m - 1, j, sti, x);",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->update(2 * sti + 1, l, mid, i, j, x);",
            "\t\telse this->update(2 * sti + 2, mid + 1, r, i, j, x);",
            "\t\tfor(int z = 0; z < this->m; z++)",
            "\t\t\tthis->st[sti][z] = this->f(this->st[2 * sti + 1][z], this->st[2 * sti + 2][z]);",
            "\t}",
            "\tT queryx(int sti, int stl, int str, int l, int r, int node){",
            "\t\tif(str < l or stl > r) return this->neutral;",
            "\t\tif(stl >= l and str <= r) return this->st[node][sti];",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->queryx(2 * sti + 1, stl, mid, l, r, node), this->queryx(2 * sti + 2, mid + 1, str, l, r, node));",
            "\t}",
            "\tT query(int sti, int stl, int str, int x, int y, int l, int r){",
            "\t\tif(str < x or stl > y) return this->neutral;",
            "\t\tif(stl >= x and str <= y) return this->queryx(0, 0, this->m - 1, l, r, sti);",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->query(2 * sti + 1, stl, mid, x, y, l, r), this->query(2 * sti + 2, mid + 1, str, x, y, l, r));",
            "\t}",
            "\tpublic:",
            "\t\tSegmentTree2D(vector<vector<T>>& a, T neutral, T (*f)(T, T), T (*u)(T, T)): n(a.size()), m(a[0].size()){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->sizen = 2 * (int)pow(2, (int)(ceil(LOG2(this->n)))) - 1;",
            "\t\t\tthis->sizem = 2 * (int)pow(2, (int)(ceil(LOG2(this->m)))) - 1;",
            "\t\t\tst = vector<vector<T>>(this->sizen, vector<T>(this->sizem, neutral));",
            "\t\t\tfor(int i = 0; i < this->n; i++)",
            "\t\t\t\tthis->update(0, 0, this->n - 1, i, a[i]);",
            "\t\t};",
            "\t\tSegmentTree2D(int n, int m, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n), m(m){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->sizen = 2 * (int)pow(2, (int)(ceil(LOG2(n)))) - 1;",
            "\t\t\tthis->sizem = 2 * (int)pow(2, (int)(ceil(LOG2(m)))) - 1;",
            "\t\t\tst = vector<vector<T>>(this->sizen, vector<T>(this->sizem, neutral));",
            "\t\t};",
            "\t\tvoid update(int i, int j, T x){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, j, x);",
            "\t\t};",
            "\t\tvoid update(int i, vector<T>& a){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, a);",
            "\t\t};",
            "\t\tT query(int x1, int y1, int x2, int y2){",
            "\t\t\treturn this->query(0, 0, this->n - 1, x1, y1, x2, y2);",
            "\t\t};",
            "};"
        ],
        "description": "Class for 2D segmenet tree"
    },
    "Fenwick tree":{
        "prefix": "fenwicktree",
        "body": [
            "template <class T> class FenwickTree{",
            "\tint n;",
            "\tT neutral;",
            "\tvector<T> ft;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tpublic:",
            "\t\tFenwickTree(int n, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n), neutral(neutral){",
            "\t\t\tft.assign(n + 1, neutral);",
            "\t\t\tthis->f = f, this->u = u;",
            "\t\t};",
            "\t\tFenwickTree(vector<T>& e, T neutral, T (*f)(T, T), T (*u)(T, T)): n(e.size()), neutral(neutral){",
            "\t\t\tft.assign(n + 1, neutral);",
            "\t\t\tthis->f = f, this->u = u;",
            "\t\t\tfor(int i = 0; i < n; i++)",
            "\t\t\t\tthis->update(i, e[i]);",
            "\t\t};",
            "\t\tT query(int i){",
            "\t\t\tT ans = this->neutral;",
            "\t\t\tfor(i++; i > 0; i -= (i & -i))",
            "\t\t\t\tans = this->f(ans, this->ft[i]);",
            "\t\t\treturn ans;",
            "\t\t};",
            "\t\tT query(int i, int j){",
            "\t\t\treturn this->query(j) - this->query(i - 1);",
            "\t\t};",
            "\t\tvoid update(int i, T x){",
            "\t\t\tfor(i++; i <= this->n; i += (i & -i))",
            "\t\t\t\tthis->ft[i] = this->u(this->ft[i], x);",
            "\t\t};",
            "};"
        ],
        "description": "Class for Fenwick tree"
    },
    "2D Fenwick Tree":{
        "prefix": "2dfenwictree",
        "body": [
            "template <class T> class FenwickTree2D{",
            "\tint n, m;",
            "\tT neutral;",
            "\tvector<vector<T>> ft;",
            "\tauto (*f)(T, T) -> T;",
            "",
            "\tpublic:",
            "\t\tFenwickTree2D(int n, int m, T neutral, T (*f)(T, T)): n(n), m(m), neutral(neutral){",
            "\t\t\tft.assign(n + 1, vector<T>(m + 1, neutral));",
            "\t\t\tthis->f = f;",
            "\t\t};",
            "\t\tT query(int i, int j){",
            "\t\t\tT ans = this->neutral;",
            "\t\t\tfor(i++; i > 0; i -= (i & -i))",
            "\t\t\t\tfor(int z = j + 1; z > 0; z -= (z & -z))",
            "\t\t\t\t\tans = this->f(ans, this->ft[i][z]);",
            "\t\t\treturn ans;",
            "\t\t}",
            "\t\tT query(int x1, int y1, int x2, int y2){",
            "\t\t\treturn (this->query(x2, y2) - this->query(x2, y1 - 1) - this->query(x1 - 1, y2) + this->query(x1 - 1, y1 - 1));",
            "\t\t}",
            "\t\tvoid update(int i, int j, T x){",
            "\t\t\tfor(i++; i <= this->n; i += (i & -i))",
            "\t\t\t\tfor(int z = j + 1; z <= this->m; z += (z & -z))",
            "\t\t\t\t\tthis->ft[i][z] = this->f(this->ft[i][z], x);",
            "\t\t};",
            "};"
        ],
        "description": "Class for 2D Fenwick tree"
    },
    "Persistent segment tree":{
        "prefix": "persistentsegmenttree",
        "body": [
            "template <class T> class PersistentSegmentTree{",
            "\tstruct Node{",
            "\t\tT element;",
            "\t\tNode* left;",
            "\t\tNode* right;",
            "",
            "\t\tNode(){};",
            "\t\tNode(T element, Node* l, Node* r): element(element), left(l), right(r) {};",
            "\t\t~Node(){",
            "\t\t\tif(this->left != NULL) delete this->left;",
            "\t\t\tif(this->right != NULL) delete this->right; ",
            "\t\t};",
            "\t};",
            "",
            "\tint nds, n;",
            "\tT neutral;",
            "\tvector<Node*> root;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tvoid build(Node* e, int l, int r, vector<T>& element){",
            "\t\tif(l == r){",
            "\t\t\te->element = this->u(e->element, element[l]);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\te->left = new Node(this->neutral, NULL, NULL);",
            "\t\te->right = new Node(this->neutral, NULL, NULL);",
            "\t\tthis->build(e->left, l, mid, element);",
            "\t\tthis->build(e->right, mid + 1, r, element);",
            "\t\te->element = this->f(e->left->element, e->right->element);",
            "\t};",
            "",
            "\tT query(Node* e, int l, int r, int i, int j){",
            "\t\tif(i > r or j < l or l > r) return this->neutral;",
            "\t\tif(i <= l and r <= j) return e->element;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\treturn this->f(this->query(e->left, l, mid, i, j), this->query(e->right, mid + 1, r, i, j));",
            "\t}",
            "",
            "\tvoid update(Node* prev, Node* e, int l, int r, int i, T x){",
            "\t\tif(i > r or i < l or l > r) return;",
            "\t\tif(l == r){",
            "\t\t\te->element = this->u(e->element, x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(i <= mid){",
            "\t\t\te->right = prev->right;",
            "\t\t\te->left = new Node(this->neutral, NULL, NULL);",
            "\t\t\tthis->update(prev->left, e->left, l, mid, i, x);",
            "\t\t} else {",
            "\t\t\te->left = prev->left;",
            "\t\t\te->right = new Node(this->neutral, NULL, NULL);",
            "\t\t\tthis->update(prev->right, e->right, mid + 1, r, i, x);",
            "\t\t}",
            "\t\te->element = this->f(e->left->element, e->right->element);",
            "\t}",
            "\tpublic:",
            "\t\tPersistentSegmentTree(){};",
            "\t\tPersistentSegmentTree(vector<T>& elements, T neutral, T (*f)(T, T), T (*u)(T, T)){",
            "\t\t\tthis->neutral = neutral, this->f = f, this->u = u;",
            "\t\t\tthis->root.push_back(new Node(this->neutral, NULL, NULL));",
            "\t\t\tthis->n = elements.size();",
            "\t\t\tthis->nds = 0;",
            "\t\t\tthis->build(this->root[0], 0, this->n - 1, elements);",
            "\t\t};",
            "\t\tPersistentSegmentTree(int n, T neutral, T (*f)(T, T), T (*u)(T, T)){",
            "\t\t\tvector<T> aux(n, neutral);",
            "\t\t\tthis->neutral = neutral, this->f = f, this->u = u;",
            "\t\t\tthis->root.push_back(new Node(this->neutral, NULL, NULL));",
            "\t\t\tthis->n = n;",
            "\t\t\tthis->nds = 0;",
            "\t\t\tthis->build(this->root[0], 0, n - 1, this->n - 1, aux);",
            "\t\t};",
            "\t\t~PersistentSegmentTree(){",
            "\t\t\tfor(int i = 0; i <= this->nds; i++) delete this->root[i];",
            "\t\t};",
            "\t\tT query(int v, int l, int r){",
            "\t\t\tif(this->nds < v) return this->neutral;",
            "\t\t\treturn this->query(this->root[v], 0, this->n - 1, l, r);",
            "\t\t};",
            "\t\tvoid update(int i, T x){",
            "\t\t\tthis->root.push_back(new Node(this->neutral, NULL, NULL));",
            "\t\t\tthis->nds++;",
            "\t\t\tthis->update(this->root[this->nds - 1], this->root[this->nds], 0, this->n - 1, i, x);",
            "\t\t};",
            "};"
        ],
        "description": "Class for Persistent segment tree"
    }
	  
}