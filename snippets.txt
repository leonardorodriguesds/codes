{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
    // }
    "Starting":{
        "prefix": "start",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define INF             (1e9 + 7)",
            "#define SINF            (1e18)",
            "#define all(a)          a.begin(), a.end()",
            "#define fill(t,v)       memset(t, v, sizeof(t))",
            "#define sz(a)           ((int)(a.size()))",
            "#define LOG2(X)         ((unsigned) (8*sizeof(unsigned long long) - __builtin_clzll((X)) - 1))",
            "#define uIndex(x, v)     (upper_bound(all(v), x) - v.begin())",
            "#define lIndex(x, v)     (lower_bound(all(v), x) - v.begin())",
            "typedef long long ll;",
            "typedef pair<int, int> ii;",
            "typedef vector<int> vi;",
            "typedef vector<vi> vvi;",
            "typedef vector<ii> vii;",
            "typedef vector<vii> vvii;",
            "typedef vector<pair<int, ii>> vpii;",
            "typedef set<int> si;",
            "typedef map<string, int> msi;",
            "typedef vector<string> vs;",
            "",
            "int main(){",
            "\t$0",
            "\treturn 0;",
           "}"
        ],
        "description": "All stuffs for starting code"
    },
    "Binary search":{
        "prefix": "binsearch",
        "body": [
            "int left, right, middle;",
            "left = 0;",
            "right = ${max};",
            "while(left <= right){",
            "\tmiddle = (left + right) / 2;",
            "\t$0",
            "}"
        ],
        "description": "Template binary search"
    },
    "UnionFind":{
        "prefix": "unionfind",
        "body": [
            "class UnionFind{",
            "\tvi id, size;",
            "\t",
            "\tint _find(int i){",
            "\t\tif(id[i] == i) return i;",
            "\t\treturn id[i] = _find(id[i]);",
            "\t}",
            "\tvoid _union(int i, int j){",
            "\t\tint p = _find(i);",
            "\t\tint q = _find(j);",
            "\t\tif(p == q) return;",
            "\t\tif(size[p] > size[q]) swap(p, q);",
            "\t\tid[p] = q;",
            "\t\tsize[q] += size[p];",
            "\t\ttotal--;",
            "\t}",
            "\t",
            "\tpublic:",
            "\t\tint total;",
            "\t\tUnionFind(int n): total(n), id(n, 0), size(n, 1){",
            "\t\t\tfor (int i = 0; i < n; i++) id[i] = i;",
            "\t\t};",
            "\t\tint find(int i){ return _find(i); };",
            "\t\tvoid c_union(int i, int j){ return _union(i, j); };",
            "};"
        ],
        "description": "Template for union find"
    },
    "Kruskal's algorithm":{
        "prefix": "kruskal",
        "body": [
            "${1|vpii,int,ll|} kruskal(int n, vpii& edges){",
            "\tUnionFind uf(n);",
            "\t${1} ans = 0;",
            "\tsort(all(edges));",
            "\tfor(auto edge: edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t\tans += edge.first;",
            "\t}",
            "\treturn ans;",
            "}"
        ],
        "description": "Template for Kruskal's algorithm"
    },
    "Prim's algorithm":{
        "prefix": "Prim's",
        "body": [
            "vii prims_mst(int n, vvii& graph){",
            "\tvii mst;",
            "\tint inMST[n];",
            "\tint coust[n];",
            "\tint parent[n];",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tcoust[i] = INF, inMST[i] = -1, parent[i] = -1;",
            "\tpriority_queue<ii, vector<ii>, greater<ii>> aux;",
            "\taux.emplace(0, 0);",
            "\tcoust[0] = 0;",
            "\tint u, dt;",
            "\tfor(int i = 0; i < n - 1; i++){",
            "\t\ttie(dt, u) = aux.top(), aux.pop();",
            "\t\tinMST[u] = 1;",
            "\t\tfor(auto e: graph[u]){",
            "\t\t\tif(!~inMST[e.second] and e.first < coust[e.second])",
            "\t\t\t\tparent[e.second] = u, aux.push(e), coust[e.second] = e.first;",
            "\t\t}",
            "\t}",
            "\tfor(int i = 1; i < n; i++)",
            "\t\tmst.emplace_back(i, parent[i]);",
            "\treturn mst;",
            "}"
        ],
        "description": "Template for Prim's algorithm"
    },
    "ForN code":{
        "prefix": "forN",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\t$0",
            "}",
        ],
        "description": "For 0 to N code"
    },
    "ForArray code":{
        "prefix": "forArray",
        "body": [
            "for(int ${index} = 0; ${index} < sz(${array}); ${index}++){",
            "\t$0",
            "}",
        ],
        "description": "For through array"
    },
    "ForN Scanf2":{
        "prefix": "nscanf2",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\tint ${a}, ${b};",
            "\tscanf(\"%d %d\", &${a}, &${b});",
            "\t$0",
            "}",
        ],
        "description": "For from 0 to n and scanf 2 elements"
    },
    "ForN Scanf3":{
        "prefix": "nscanf3",
        "body": [
            "for(int ${index} = 0; ${index} < ${size}; ${index}++){",
            "\tint ${a}, ${b}, ${w};",
            "\tscanf(\"%d %d %d\", &${a}, &${b}, &${w});",
            "\t$0",
            "}",
        ],
        "description": "For from 0 to n and scanf 3 elements"
    },
    "Basic graph":{
        "prefix": "graph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tlist<${2|int,ii|}> *adj;",
            "\tint *visited;",
            "\tvoid resetVisited(){",
            "\t\tmemset(this->visited, -1, this->n * sizeof(int));",
            "\t}",
            "",
            "\tpublic:",
            "\t\tGraph(int n): n(n){",
            "\t\t\tthis->adj = new list<${2|int,ii|}>[n];",
            "\t\t\tthis->visited = new int[n];",
            "\t\t};",
            "\t\t~Graph(){",
            "\t\t\tdelete [] this->adj;",
            "\t\t\tdelete [] this->visited;",
            "\t\t};",
            "\t\tvoid addEdge(int u, int v, int c, bool directed = ${1|true,false|});",
            "};",
            "void Graph::addEdge(int u, int v, int c, bool directed){",
            "\tthis->adj[u].${3|push_back,emplace_back|}(c, v);",
            "\tif(directed)",
            "\t\tthis->adj[v].${3|push_back,emplace_back|}(c, u);",
            "}"
        ],
        "description": "basic system graph"
    },
    "bfs graph":{
        "prefix": "bfsgraph",
        "body": [
            "int bfs(int start, int end);",
            "int Graph::bfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tqueue<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.front();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
        ],
        "description": "bfs for graph class"
    },
    "Graph completed template":{
        "prefix": "cgraph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tlist<ii> *adj;",
            "\tvpii edges;",
            "\tint *visited;",
            "",
            "\tpublic:",
            "\t\tGraph(int n);",
            "\t\t~Graph();",
            "\t\tvoid addEdge(int u, int v, int c, bool directed = false);",
            "\t\tvoid removeAdj(int u, int v, bool directed = false);",
            "\t\tvoid removeEdge(int u, int v);",
            "\t\tvii primsMST();",
            "\t\tvpii kruskalMST();",
            "\t\tll djikstra(int start, int end);",
            "\t\tint bfs(int start, int end);",
            "\t\tint dfs(int start, int end);",
            "};",
            "Graph::Graph(int n){",
            "\tthis->n = n;",
            "\tthis->adj = new list<ii>[n];",
            "\tthis->visited = new int[n];",
            "}",
            "Graph::~Graph(){",
            "\tdelete [] this->adj;",
            "\tdelete [] this->visited;",
            "}",
            "void Graph::addEdge(int u, int v, int c, bool directed){",
            "\tthis->adj[u].emplace_back(c, v);",
            "\tthis->edges.emplace_back(c, make_pair(u, v));",
            "\tif(directed)",
            "\t\tthis->adj[v].emplace_back(c, u);",
            "}",
            "void Graph::removeAdj(int u, int v, bool directed){",
            "\tfor(auto it = this->adj[u].begin(); it != this->adj[u].end(); it++){",
            "\t\tif(it->second == v)",
            "\t\t\tthis->adj[u].erase(it); ",
            "\t}",
            "\tif(!directed)",
            "\t\treturn;",
            "\tfor(auto it = this->adj[v].begin(); it != this->adj[v].end(); it++){",
            "\t\tif(it->second == u)",
            "\t\t\tthis->adj[v].erase(it); ",
            "\t}",
            "}",
            "void Graph::removeEdge(int u, int v){",
            "\tfor(auto it = this->edges.begin(); it != this->edges.end(); it++){",
            "\t\tif((it->second.first == u and it->second.second == v) or (it->second.first == v and it->second.second == u))",
            "\t\t\tthis->edges.erase(it);",
            "\t}",
            "}",
            "vii Graph::primsMST(){",
            "\tvii mst;",
            "\tint inMST[n];",
            "\tint coust[n];",
            "\tint parent[n];",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tcoust[i] = INF, inMST[i] = -1, parent[i] = -1;",
            "\tpriority_queue<ii, vector<ii>, greater<ii>> aux;",
            "\taux.emplace(0, 0);",
            "\tcoust[0] = 0;",
            "\tint u, dt;",
            "\tfor(int i = 0; i < n - 1; i++){",
            "\t\ttie(dt, u) = aux.top(), aux.pop();",
            "\t\tinMST[u] = 1;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~inMST[e.second] and e.first < coust[e.second])",
            "\t\t\t\tparent[e.second] = u, aux.push(e), coust[e.second] = e.first;",
            "\t\t}",
            "\t}",
            "\tfor(int i = 1; i < n; i++)",
            "\t\tmst.emplace_back(i, parent[i]);",
            "\treturn mst;",
            "}",
            "vpii Graph::kruskalMST(){",
            "\tUnionFind uf(this->n);",
            "\tvpii ans;",
            "\tsort(all(this->edges));",
            "\tfor(auto edge: this->edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t}",
            "\treturn ans;",
            "}",
            "int Graph::dfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tstack<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.top();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
            "int Graph::bfs(int start, int end){",
            "\tfill(this->visited, -1);",
            "\tqueue<ii> aux;",
            "\taux.emplace(start, 0);",
            "\tthis->visited[start] = 1;",
            "\tint u, dt;",
            "\twhile(!(aux.empty())){",
            "\t\ttie(u, dt) = aux.front();",
            "\t\taux.pop();",
            "\t\tif(u == end)",
            "\t\t\treturn dt;",
            "\t\tfor(auto e: this->adj[u]){",
            "\t\t\tif(!~this->visited[e.second]){",
            "\t\t\t\tthis->visited[e.second] = 1;",
            "\t\t\t\taux.emplace(e.second, dt + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
        ],
        "description": "Graph completed template"
    },
    "Kruskal Graph template":{
        "prefix": "kgraph",
        "body": [
            "class Graph{",
            "\tint n;",
            "\tvpii edges;",
            "\tint *visited;",
            "",
            "\tpublic:",
            "\t\tGraph(int n);",
            "\t\t~Graph();",
            "\t\tvoid addEdge(int u, int v, int c);",
            "\t\tvpii kruskalMST();",
            "};",
            "Graph::Graph(int n){",
            "\tthis->n = n;",
            "\tthis->visited = new int[n];",
            "}",
            "Graph::~Graph(){",
            "\tdelete [] this->visited;",
            "}",
            "void Graph::addEdge(int u, int v, int c){",
            "\tthis->edges.emplace_back(c, make_pair(u, v));",
            "}",
            "vpii Graph::kruskalMST(){",
            "\tUnionFind uf(this->n);",
            "\tvpii ans;",
            "\tsort(all(this->edges));",
            "\tfor(auto edge: this->edges){",
            "\t\tif(uf.find(edge.second.first) == uf.find(edge.second.second)) continue;",
            "\t\tuf.c_union(edge.second.first, edge.second.second);",
            "\t\tans.emplace_back(edge.first, make_pair(edge.second.first, edge.second.second));",
            "\t}",
            "\treturn ans;",
            "}",
        ],
        "description": "Kruskal Graph set"
    },
    "Min Sparce table class":{
        "prefix": "minsparcetable",
        "body": [
            "class SparseT{",
            "\tint n;",
            "\tint lgN;",
            "\t${type}* data;",
            "\t${type}** table;",
            "\tauto (*f)(${type} a, ${type} b)->${type};",
            "",
            "\tvoid buildsparsetable();",
            "\tpublic:",
            "\t\tSparseT(int n);",
            "\t\t~SparseT();",
            "\t\tvoid buildTable(${type} (*f)(${type}, ${type}));",
            "\t\t${type} query(${type} i, ${type} j);",
            "};",
            "SparseT::SparseT(int n){",
            "\tthis->n = n;",
            "\tthis->lgN = (int)LOG2(n);",
            "\tthis->data = new int[n];",
            "\tthis->table = new ${type}*[n];",
            "\tfor(int i = 0; i < n; i++)",
            "\t\tthis->table[i] = new ${type}[this->lgN + 1];",
            "}",
            "SparseT::~SparseT(){",
            "\tdelete [] this->data;",
            "\tfor(int i = 0; i < n; i++)",
            "\t\tdelete[] this->table[i];",
            "\tdelete [] this->table;",
            "}",
            "void SparseT::buildTable(${type} (*f)(${type}, ${type})){",
            "\tfor(int i = 0; i < this->n; i++)",
            "\t\tscanf(\"${macrotype}\", &this->data[i]);",
            "\tthis->f = f;",
            "\tthis->buildsparsetable();",
            "}",
            "void SparseT::buildsparsetable(){",
            "\tfor(int i = 0; i < this->n; i++)",
            "\t\tthis->table[i][0] = this->data[i];",
            "\tfor(int j = 1; (1 << j) <= this->n; j++)",
            "\t\tfor(int i = 0; (i + (1 << j) - 1) < n; i++)",
            "\t\t\tthis->table[i][j] = this->f(this->table[i][j - 1], ",
            "\t\t\t\t\t\t\t\tthis->table[i + (1 << (j - 1))][j - 1]);",
            "}",
            "${type} SparseT::query(int l, int r){",
            "\tint j = (int)LOG2(r - l + 1);",
            "\treturn this->f(this->table[l][j], this->table[r - (1 << j) + 1][j]);",
            "}"
        ],
        "description": "Sparce table to min value"
    },
    "Rabin Karp algorithm":{
        "prefix": "rabinkarp",
        "body": [
            "class RabinKarp{",
            "\tint n, m, p;",
            "\tstring sb;",
            "\tvector<ll> hsh, pw;",
            "\t",
            "\tpublic:",
            "\t\tRabinKarp(string str, int p, int m): sb(str), p(p), m(m){",
            "\t\t\tthis->n = sz(str);",
            "\t\t\thsh.resize(n), pw.resize(n);",
            "\t\t\thsh[0] = str[0]; pw[0] = 1;",
            "\t\t\tfor(int i = 1; i < n; i++){",
            "\t\t\t\thsh[i] = ((hsh[i - 1] * p) + str[i]) % m;",
            "\t\t\t\tpw[i] = (pw[i - 1] * p) % m;",
            "\t\t\t}",
            "\t\t};",
            "\t\tll hash(int i, int j){",
            "\t\t\tll ans = hsh[j];",
            "\t\t\tif(i > 0) ans = (ans - ((hsh[i - 1] * 1ll * pw[j - i + 1]) % m) + m) % m;",
            "\t\t\treturn ans;",
            "\t\t}",
            "\t\tll gethash(string str, int z){",
            "\t\t\tll ans = str[0];",
            "\t\t\tfor(int i = 1; i < z; i++)",
            "\t\t\t\tans = ((ans * p) + str[i]) % m;",
            "\t\t\treturn ans;",
            "\t\t};",
            "\t\tint check(string str){",
            "\t\t\tint z = sz(str), i;",
            "\t\t\tll lookfor = this->gethash(str, z);",
            "\t\t\tbool flag = true;",
            "\t\t\tfor(i = 0; i < (this->n - z + 1) and flag; i++){",
            "\t\t\t\tflag = flag && !(this->hash(i, (i + z - 1)) == lookfor);",
            "\t\t\t\tif(!flag)",
            "\t\t\t\t\tfor(int j = 0; j < z and !flag; j++)",
            "\t\t\t\t\t\tflag = (this->sb[i + j] != str[j]);",
            "\t\t\t}",
            "\t\t\treturn (flag)? -1 : --i;",
            "\t\t};",
            "};"
        ],
        "description": "Rabin karp algorithm to pattern search"
    },
    "segment tree":{
        "prefix": "segmenttree",
        "body": [
            "template <class T> class SegmentTree{",
            "\tint n, size;",
            "\tT neutral;",
            "\tvector<T> num;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tvoid update(int sti, int l, int r, int i, T x){",
            "\t\tif(l == r and l == i){",
            "\t\t\tthis->num[sti] = this->u(this->num[sti], x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i)",
            "\t\t\treturn;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tthis->update(2 * sti + 1, l, mid, i, x);",
            "\t\tthis->update(2 * sti + 2, mid + 1, r, i, x);",
            "\t\tthis->num[sti] = this->f(this->num[2 * sti + 1], this->num[2 * sti + 2]);",
            "\t}",
            "\tT query(int sti, int stl, int str, int l, int r){",
            "\t\tif(str < l or stl > r)",
            "\t\t\treturn this->neutral;",
            "\t\tif(stl >= l and str <= r)",
            "\t\t\treturn this->num[sti];",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->query(2 * sti + 1, stl, mid, l, r), this->query(2 * sti + 2, mid + 1, str, l, r));",
            "\t}",
            "\tpublic:",
            "\t\tSegmentTree(int n, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->size = 2 * (int)pow(2, (int)(ceil(log2(n)))) - 1;",
            "\t\t\tnum = vector<T>(this->size, 0);",
            "\t\t};",
            "\t\tvoid update(int i, T x){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, x);",
            "\t\t};",
            "\t\tT query(int l, int r){",
            "\t\t\treturn this->query(0, 0, this->n - 1, l, r);",
            "\t\t};",
            "};"
        ],
        "description": "Class for linear segment tree"
    },
    "SegmentTree2D":{
        "prefix": "2dsegmenttree",
        "body":[
            "template <class T> class SegmentTree2D{",
            "\tint n, m, sizen, sizem;",
            "\tT neutral;",
            "\tvector<vector<T>> st;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tvoid updatex(int sti, int l, int r, int i, int node, T x){",
            "\t\tif(l == r and l == i){",
            "\t\t\tthis->st[node][sti] = this->u(this->st[node][sti], x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->updatex(2 * sti + 1, l, mid, i, node, x);",
            "\t\telse this->updatex(2 * sti + 2, mid + 1, r, i, node, x);",
            "\t\tthis->st[node][sti] = this->f(this->st[node][2 * sti + 1], this->st[node][2 * sti + 2]);",
            "\t}",
            "\tvoid update(int sti, int l, int r, int i, vector<T>& a){",
            "\t\tif(l == r and l == i){",
            "\t\t\tfor(int j = 0; j < this->m; j++)",
            "\t\t\t\tthis->updatex(0, 0, this->m - 1, j, sti, a[j]);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->update(2 * sti + 1, l, mid, i, a);",
            "\t\telse this->update(2 * sti + 2, mid + 1, r, i, a);",
            "\t\tfor(int z = 0; z < this->m; z++)",
            "\t\t\tthis->st[sti][z] = this->f(this->st[2 * sti + 1][z], this->st[2 * sti + 2][z]);",
            "\t}",
            "\tvoid update(int sti, int l, int r, int i, int j, T x){",
            "\t\tif(l == r and l == i)",
            "\t\t\treturn this->updatex(0, 0, this->m - 1, j, sti, x);",
            "\t\tif(l > i or r < i) return;",
            "\t\tint mid = l + (r - l) / 2;",
            "\t\tif(l <= i and i <= mid) this->update(2 * sti + 1, l, mid, i, j, x);",
            "\t\telse this->update(2 * sti + 2, mid + 1, r, i, j, x);",
            "\t\tfor(int z = 0; z < this->m; z++)",
            "\t\t\tthis->st[sti][z] = this->f(this->st[2 * sti + 1][z], this->st[2 * sti + 2][z]);",
            "\t}",
            "\tT queryx(int sti, int stl, int str, int l, int r, int node){",
            "\t\tif(str < l or stl > r) return this->neutral;",
            "\t\tif(stl >= l and str <= r) return this->st[node][sti];",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->queryx(2 * sti + 1, stl, mid, l, r, node), this->queryx(2 * sti + 2, mid + 1, str, l, r, node));",
            "\t}",
            "\tT query(int sti, int stl, int str, int x, int y, int l, int r){",
            "\t\tif(str < x or stl > y) return this->neutral;",
            "\t\tif(stl >= x and str <= y) return this->queryx(0, 0, this->m - 1, l, r, sti);",
            "\t\tint mid = stl + (str - stl) / 2;",
            "\t\treturn this->f(this->query(2 * sti + 1, stl, mid, x, y, l, r), this->query(2 * sti + 2, mid + 1, str, x, y, l, r));",
            "\t}",
            "\tpublic:",
            "\t\tSegmentTree2D(vector<vector<T>>& a, T neutral, T (*f)(T, T), T (*u)(T, T)): n(a.size()), m(a[0].size()){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->sizen = 2 * (int)pow(2, (int)(ceil(LOG2(this->n)))) - 1;",
            "\t\t\tthis->sizem = 2 * (int)pow(2, (int)(ceil(LOG2(this->m)))) - 1;",
            "\t\t\tst = vector<vector<T>>(this->sizen, vector<T>(this->sizem, neutral));",
            "\t\t\tfor(int i = 0; i < this->n; i++)",
            "\t\t\t\tthis->update(0, 0, this->n - 1, i, a[i]);",
            "\t\t};",
            "\t\tSegmentTree2D(int n, int m, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n), m(m){",
            "\t\t\tthis->f = f, this->u = u, this->neutral = neutral;",
            "\t\t\tthis->sizen = 2 * (int)pow(2, (int)(ceil(LOG2(n)))) - 1;",
            "\t\t\tthis->sizem = 2 * (int)pow(2, (int)(ceil(LOG2(m)))) - 1;",
            "\t\t\tst = vector<vector<T>>(this->sizen, vector<T>(this->sizem, neutral));",
            "\t\t};",
            "\t\tvoid update(int i, int j, T x){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, j, x);",
            "\t\t};",
            "\t\tvoid update(int i, vector<T>& a){",
            "\t\t\treturn this->update(0, 0, this->n - 1, i, a);",
            "\t\t};",
            "\t\tT query(int x1, int y1, int x2, int y2){",
            "\t\t\treturn this->query(0, 0, this->n - 1, x1, y1, x2, y2);",
            "\t\t};",
            "};"
        ],
        "description": "Class for 2D segmenet tree"
    },
    "Fenwick tree":{
        "prefix": "fenwicktree",
        "body": [
            "template <class T> class FenwickTree{",
            "\tint n;",
            "\tT neutral;",
            "\tvector<T> ft;",
            "\tauto (*f)(T, T) -> T;",
            "\tauto (*u)(T, T) -> T;",
            "",
            "\tpublic:",
            "\t\tFenwickTree(int n, T neutral, T (*f)(T, T), T (*u)(T, T)): n(n), neutral(neutral){",
            "\t\t\tft.assign(n + 1, neutral);",
            "\t\t\tthis->f = f, this->u = u;",
            "\t\t};",
            "\t\tFenwickTree(vector<T>& e, T neutral, T (*f)(T, T), T (*u)(T, T)): n(e.size()), neutral(neutral){",
            "\t\t\tft.assign(n + 1, neutral);",
            "\t\t\tthis->f = f, this->u = u;",
            "\t\t\tfor(int i = 0; i < n; i++)",
            "\t\t\t\tthis->update(i, e[i]);",
            "\t\t};",
            "\t\tT query(int i){",
            "\t\t\tT ans = this->neutral;",
            "\t\t\tfor(i++; i > 0; i -= (i & -i))",
            "\t\t\t\tans = this->f(ans, this->ft[i]);",
            "\t\t\treturn ans;",
            "\t\t};",
            "\t\tT query(int i, int j){",
            "\t\t\treturn this->query(j) - this->query(i - 1);",
            "\t\t};",
            "\t\tvoid update(int i, T x){",
            "\t\t\tfor(i++; i <= this->n; i += (i & -i))",
            "\t\t\t\tthis->ft[i] = this->u(this->ft[i], x);",
            "\t\t};",
            "};"
        ],
        "description": "Class for Fenwick tree"
    },
    "2D Fenwick Tree":{
        "prefix": "2dfenwictree",
        "body": [
            "template <class T> class FenwickTree2D{",
            "\tint n, m;",
            "\tT neutral;",
            "\tvector<vector<T>> ft;",
            "\tauto (*f)(T, T) -> T;",
            "",
            "\tpublic:",
            "\t\tFenwickTree2D(int n, int m, T neutral, T (*f)(T, T)): n(n), m(m), neutral(neutral){",
            "\t\t\tft.assign(n + 1, vector<T>(m + 1, neutral));",
            "\t\t\tthis->f = f;",
            "\t\t};",
            "\t\tT query(int i, int j){",
            "\t\t\tT ans = this->neutral;",
            "\t\t\tfor(i++; i > 0; i -= (i & -i))",
            "\t\t\t\tfor(int z = j + 1; z > 0; z -= (z & -z))",
            "\t\t\t\t\tans = this->f(ans, this->ft[i][z]);",
            "\t\t\treturn ans;",
            "\t\t}",
            "\t\tT query(int x1, int y1, int x2, int y2){",
            "\t\t\treturn (this->query(x2, y2) - this->query(x2, y1 - 1) - this->query(x1 - 1, y2) + this->query(x1 - 1, y1 - 1));",
            "\t\t}",
            "\t\tvoid update(int i, int j, T x){",
            "\t\t\tfor(i++; i <= this->n; i += (i & -i))",
            "\t\t\t\tfor(int z = j + 1; z <= this->m; z += (z & -z))",
            "\t\t\t\t\tthis->ft[i][z] = this->f(this->ft[i][z], x);",
            "\t\t};",
            "};"
        ],
        "description": "Class for 2D Fenwick tree"
    }
}